#ifndef TEAMING_PLANNER_H
#define TEAMING_PLANNER_H

#include <ros/ros.h>
#include <ros/subscribe_options.h>
#include <unordered_map>
#include <string>

#include "../../../distributed_multi_robot_formation/src/Common/Common.h"
#include "../../../distributed_multi_robot_formation/src/DistributedMultiRobotFormation.h"
#include "../../../distributed_multi_robot_formation/src/DistributedMultiRobotFormationHandler.h"
#include "../../../distributed_multi_robot_formation/src/ProcessPointCloud/ProcessPointCloud.h"

#include "../../../distributed_global_path_planner/src/DistributedGlobalPathPlannerHandler.h"
#include "../../../distributed_global_path_planner/src/DistributedGlobalPathPlanner.h"

#include "../../../Common/ConstantsEnum.h"
#include "../../../Common/Config/ConfigFileReader.h"
#include "teaming_planner_constants.h"

#include <geometry_msgs/PointStamped.h>
#include <geometry_msgs/PoseStamped.h>
#include <nav_msgs/Odometry.h>
#include <sensor_msgs/PointCloud.h>
#include <sensor_msgs/PointCloud2.h>
#include <sensor_msgs/point_cloud_conversion.h>

#include <std_msgs/Int8.h>
#include <std_msgs/String.h>
#include <tf/transform_listener.h>
#include <mt_msgs/pose.h>
#include <mt_msgs/mtTask.h>
#include <mt_msgs/angleIndexAndUtility.h>
#include <mt_msgs/convexRegion2D.h>
#include <mt_msgs/convexRegion3D.h>
#include <mt_msgs/phaseAndTime.h>
#include <mt_msgs/position.h>
#include <mt_msgs/posevector.h>
#include <geometry_msgs/PoseWithCovarianceStamped.h>

// If activated and follow me use history of human poses
// If activated and go there, activate consensus path planner 
// Pass the poses generated by consensun path planner to the formation generator
// Can remove goalPose callback?

class TeamingPlanner
{
    private:

        ros::NodeHandle mNh;
        ros::NodeHandle mNhPrivate;
        Common::Utils::ConfigFileReader mConfigFileReader;
        DistributedFormation::DistributedMultiRobotFormationHandler::Ptr mHandlerPtr;
        DistributedFormation::DistributedMultiRobotFormation mDistributedFormation;

        // Configurable Variables
        uint32_t mSourceSegmentId;
        double mModulePeriod;
        int mNumOfAgents;
        bool mDebugVerbose;
        double mIntervalDistance;
        double mPlanningHorizon;
        double mDesiredHeight;
        int mNumberOfAgentsInFormation;

        // Teaming Planner control variables
        TeamingPlannerConstants::ModuleState mModuleState;
        Common::Entity::MTTaskBundle mTask;

        // Drone variables
        sensor_msgs::PointCloud mSystemPointCloud;
        geometry_msgs::PoseStamped mSelft265SystemPose;
        sensor_msgs::PointCloud2 mSystemPointCloud2;
        tf::TransformListener mPoseTransformListener;
        tf::TransformListener mPointCloudTransformListener;
        tf::TransformListener mPointCloud2TransformListener;
        bool mHistoryOfHumanPosesReceived;
        bool useUWB;
        std_msgs::Bool mBoolActivatePlanner; 
        geometry_msgs::PoseStamped mUAVPoseStamped;
        std::string mUAVMode;

        // Multi Robot formation variables
        std::vector<DistributedFormation::Common::Pose> mHistoryOfHumanPoses;
        DistributedFormation::Common::Pose mHumanSystemPose;
        DistributedFormation::Common::Pose mSelfSystemPose;
        std::unordered_map<int32_t, DistributedFormation::Common::PhaseAndTime> mAgentsPhaseAndTimeMap;
        std::unordered_map<int32_t, DistributedFormation::Common::Pose> mAgentsPoseMap;
        std::unordered_map<int32_t, DistributedFormation::Common::DirectionUtility> mAgentsDirectionUtilityMap;
        std::unordered_map<int32_t, DistributedFormation::Common::ConvexRegion2D> mAgentsConvexRegion2DMap;
        std::unordered_map<int32_t, DistributedFormation::Common::ConvexRegion3D> mAgentsConvexRegion3DMap;
        std::unordered_map<int32_t, std::unordered_map<int32_t, DistributedFormation::Common::Pose>> mAgentsAssignedVirtualPoseMap;

    //    // Consensus global path variables
        std::vector<DistributedGlobalPathPlanner::Common::Pose> m_goTherePath;

        std::unordered_map<int32_t, DistributedGlobalPathPlanner::Common::PhaseAndTime> m_phasesAndTimeRecordOfAgents;
        DistributedGlobalPathPlanner::Common::PhaseAndTime m_ownAgentPhaseAndTime;

        std::unordered_map<int32_t, DistributedGlobalPathPlanner::Common::PathAndWaypointProgress> m_agentsPathAndWaypointProgress;
        DistributedGlobalPathPlanner::Common::PathAndWaypointProgress m_ownPathAndWaypointProgress;

        std::unordered_map<int32_t, std::vector<Eigen::Vector3d>> m_AgentsPlannedPath;
        std::unordered_map<int32_t, DistributedGlobalPathPlanner::Common::Pose> m_agentsPose;
        
        std::vector<Eigen::Vector3d> m_ownPlannedPath;

        std::unordered_map<int32_t, std::unordered_map<int32_t, DistributedGlobalPathPlanner::Common::PathAndCost>> m_AgentsProcessedPathOfAgents;
        std::unordered_map<int32_t, DistributedGlobalPathPlanner::Common::PathAndCost> m_ownProcessedPathOfOtherAgents;
        std::unordered_map<int32_t, std::vector<Eigen::Vector3d>> m_AgentsBestProcessedPath;
        
        std::vector<Eigen::Vector3d> m_ownBestProcessedPath;
        std::vector<DistributedGlobalPathPlanner::Common::Pose> m_ownProcessedGoTherePath;
        DistributedGlobalPathPlanner::Common::Pose m_ownAgentPose;

        // There is a probably better way to implement this but htis should do
        // Whatever lmao
        geometry_msgs::PoseWithCovarianceStamped mGunTargetPose;
        bool mgunTargetPoseRecieved;
    
        // Verbose Variables
        bool mModuleStateVerbose;
        bool mModuleTaskVerbose;

        // Publisher
        ros::Publisher mPhaseAndTimePublisher;
        ros::Publisher mPosePublisher;
        ros::Publisher mDirectionUtilityPublisher;
        ros::Publisher mConvexRegion2DPublisher;
        ros::Publisher mConvexRegion3DPublisher;
        ros::Publisher mAssignedVirtualPosePublisher;
        ros::Publisher mAssignedt265VirtualPosePublisher;
        ros::Publisher mAssignedVirtualPoseMapPublisher;
        ros::Publisher mVoxel_filter_cloudPublisher;

        // Subscribers 
        ros::Subscriber mGoalSubscriber;
        ros::Subscriber mHumanSystemPoseSubscriber;
        ros::Subscriber mSelfSystemPoseSubscriber;
        ros::Subscriber mSelft265SystemPoseSubscriber;
        ros::Subscriber mSystemPointCloudSubscriber;
        ros::Subscriber mSystemPointCloud2Subscriber;
        ros::Subscriber mGunTargetPoseSubscriber;
        ros::Subscriber mActivatePlannerSubscriber;
        ros::Subscriber mUAVmodeSubscriber;

        // Timers
        ros::Timer mModuleLoopTimer;

        // Hardcoded for now
        std::vector<ros::Subscriber> mUAVSystemPoseSubscriberVector;
        std::vector<ros::Subscriber> mUAVPhaseAndTimeSubscriberVector;
        std::vector<ros::Subscriber> mUAVDirectionUtilitySubscriberVector;
        std::vector<ros::Subscriber> mUAVConvexRegion2DSubscriberVector;
        std::vector<ros::Subscriber> mUAVConvexRegion3DSubscriberVector;
        std::vector<ros::Subscriber> mUAVAssignedVirtualPoseMapSubscriberVector;

        // Subscriber Callbacks
        void UAVModeCallback(const std_msgs::String::ConstPtr& aUAVmode);
        void activatePlannerCallback(const std_msgs::Bool::ConstPtr& aBoolActivatePlanner);
        void systemPointCloud2Callback(const sensor_msgs::PointCloud2::ConstPtr& aSystemPointCloud2);
        void selfSystemPoseCallback(const geometry_msgs::PoseStamped::ConstPtr& aSelfSystemPose);
        void selfSystemPoseCallbackUWB(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr& aSelfSystemPose);
        void selft265SystemPoseCallback(const geometry_msgs::PoseStamped::ConstPtr& aSelfSystemPose);


        void phaseTimeCallback(const mt_msgs::phaseAndTime::ConstPtr& aPhaseAndTime);
        void directionUtilityCallback(const mt_msgs::angleIndexAndUtility::ConstPtr& aDirectionUtility);
        void convexRegion2DCallback(const mt_msgs::convexRegion2D::ConstPtr& aConvexRegion2D);
        void convexRegion3DCallback(const mt_msgs::convexRegion3D::ConstPtr& aConvexRegion3D);
        void assignedVirtualPoseMapCallback(const mt_msgs::posevector::ConstPtr& aAssignedVirtualPoseMap);
        void gunCommandPoseCallback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr& aPoseWithCovarianceStamped);
        void humanSystemPoseCallback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr& aHumanSystemPose);
        // void selfSystemPoseCallback(const geometry_msgs::PoseWithCovarianceStamped::ConstPtr& aSelfSystemPose);
        void systemPoseCallback(const mt_msgs::pose::ConstPtr& aSystemPose);
        void systemPointCloudCallback(const sensor_msgs::PointCloud::ConstPtr& aSystemPointCloud);

        /*Common Functions to be binded by formation and consensus path handler */
        bool getNumberOfAgentsInTeam(int32_t& numberOfAgentsInTeam);
        bool getOwnAgentId(int32_t& ownAgentID);
        bool getOwnAgentLidarPointCloud(sensor_msgs::PointCloud& cloud);
        /*Common Functions to be binded by formation and consensus path handler */

        /*Functions to be binded by formation handler RFH means robot formation handler*/
        // Publisher Functions
        bool pubPhaseAndTimeRFH(const int32_t aAgentId, const DistributedFormation::Common::PhaseAndTime aPhaseAndTime);
        bool pubPoseRFH(const int32_t aAgentId, const DistributedFormation::Common::Pose aPose);
        bool pubDirectionUtilityRFH(const int32_t aAgentId, const DistributedFormation::Common::DirectionUtility aDirectionUtility);
        bool pubConvexRegion2DRFH(const int32_t aAgentId, const DistributedFormation::Common::ConvexRegion2D aConvexRegion2D);
        bool pubConvexRegion3DRFH(const int32_t aAgentId, const DistributedFormation::Common::ConvexRegion3D aConvexRegion3D);
        bool pubAssignedPoseRFH(const int32_t aAgentId, const DistributedFormation::Common::Pose aAssignedVirtualPose);
        bool pubAssignedPoseMapRFH(const int32_t aAgentId, const std::unordered_map<int32_t, DistributedFormation::Common::Pose> aAssignedVirtualPoseMap);

        // Get Functions 
        bool getPosesForFormationToTrackRFH(std::vector<DistributedFormation::Common::Pose>& historyOfHumanPoses);
        bool getPhaseAndTimeMapRFH(std::unordered_map<int32_t, DistributedFormation::Common::PhaseAndTime>& phaseAndTimeMap);
        bool getPoseMapRFH(std::unordered_map<int32_t, DistributedFormation::Common::Pose>& poseMap);
        bool getDirectionUtilityMapRFH(std::unordered_map<int32_t, DistributedFormation::Common::DirectionUtility>& directionUtilityMap);
        bool getConvexRegion2DMapRFH(std::unordered_map<int32_t, DistributedFormation::Common::ConvexRegion2D>& convexRegion2DMap);
        bool getConvexRegion3DMapRFH(std::unordered_map<int32_t, DistributedFormation::Common::ConvexRegion3D>& convexRegion3DMap);
        bool getAssignedVirtualPoseMapRFH(std::unordered_map<int32_t, std::unordered_map<int32_t, DistributedFormation::Common::Pose>>& assignedVirtualPoseMap);
        bool getHumanSystemPoseRFH(DistributedFormation::Common::Pose& aHumanSystemPose);
        bool getOwnUAVSystemPoseRFH(DistributedFormation::Common::Pose& aUAVSystemPose);

        void clearPhaseAndTimeMapRFH(); // Not binded
        void clearPoseMapRFH(); // Binded twice ? might be wrong 
        void clearDirectionUtilityMapRFH();
        void clearConvexRegion2DMapRFH();
        void clearConvexRegion3DMapRFH();
        void clearAssignedVirtualPoseMapRFH(); // Not binded
        /*Functions to be binded by formation handler */

        /*Functions to be binded by consensus path planner CPH means consensus path handler*/
        // // Publisher functions
        bool pubOwnPhaseAndTimeCPH(const int32_t, const DistributedGlobalPathPlanner::Common::PhaseAndTime& ownAgentPhaseAndTime);
        bool pubOwnPoseFuncCPH(const int32_t ownAgentID, const DistributedGlobalPathPlanner::Common::Pose& ownAgentPose);
        bool pubOwnPathAndWaypointProgressCPH(const int32_t, const DistributedGlobalPathPlanner::Common::PathAndWaypointProgress& goTherePathAndWaypointProgress);
        bool pubOwnPlannedPathCPH(const int32_t, const std::vector<Eigen::Vector3d>& ownPlannedPath);
        bool pubOwnProcessedPathOfAgentsCPH(const int32_t, const std::unordered_map<int32_t, DistributedGlobalPathPlanner::Common::PathAndCost>& ownProcessedPathOfAgents);
        bool pubOwnBestProcessedPathCPH(const int32_t, const std::vector<Eigen::Vector3d>& ownBestProcessedPath);
        bool pubProcessedGoTherePathCPH(const int32_t, const std::vector<DistributedGlobalPathPlanner::Common::Pose>& processedGoTherePath);

        // Get functions
        bool getGoTherePathCPH(std::vector<DistributedGlobalPathPlanner::Common::Pose>& goTherePath);
        bool getPhasesAndTimeRecordOfAgentsCPH(std::unordered_map<int32_t, DistributedGlobalPathPlanner::Common::PhaseAndTime>& phasesAndTimeRecordOfAgents);
        bool getOwnAgentPoseCPH(DistributedGlobalPathPlanner::Common::Pose& ownAgentPose);
        bool getOtherAgentsPoseCPH(std::unordered_map<int32_t, DistributedGlobalPathPlanner::Common::Pose>& agentsPose);
        bool getAgentsPathAndWaypointProgressCPH(std::unordered_map<int32_t, DistributedGlobalPathPlanner::Common::PathAndWaypointProgress>& agentsGoTherePathAndWaypointProgres);
        bool getAgentsPlannedPathCPH(std::unordered_map<int32_t, std::vector<Eigen::Vector3d>>& agentsPlannedPath);
        bool getAgentsProcessedPathOfAgentsCPH(std::unordered_map<int32_t, std::unordered_map<int32_t, DistributedGlobalPathPlanner::Common::PathAndCost>>& agentsProcessedPath);
        bool getAgentsBestProcessedPathCPH(std::unordered_map<int32_t, std::vector<Eigen::Vector3d>>& agentsBestProcessedPath);

        // Clear
        void clearAgentsPoseBufferCPH();
        void clearAgentsProcessedPathOfAgentsBufferCPH();
        void clearAgentsPlannedPathBufferCPH();
        void clearAgentsPathAndWaypointProgressBufferCPH();
        /*Functions to be binded by consensus path planner CPH means consensus path handler */

        // Functions 
        bool switchToGunTargetPose(const int32_t aAgentId);
        void teamingPlannerMain();
        bool checkAndAddHumanSystemPose(std::vector<DistributedFormation::Common::Pose>& historyOfHumanPoses, const DistributedFormation::Common::Pose aPose);
        double euclideanDistance(const double x1, const double y1, const double x2, const double y2);
        geometry_msgs::PoseStamped subtractPoseStamped(geometry_msgs::PoseStamped previous, geometry_msgs::PoseStamped current); // current - previous
        geometry_msgs::PoseStamped addPoseStamped(geometry_msgs::PoseStamped vector_pose, geometry_msgs::PoseStamped current);

        // Timer Functions 
        void moduleLoopCallback(const ros::TimerEvent& event);

        // KIV stuff
        void goalCallback(const mt_msgs::pose::ConstPtr& aGoal);
        // void taskCallback(const mt_msgs::mtTask::ConstPtr& aTask);

    public:
        TeamingPlanner(const ros::NodeHandle& nh, const ros::NodeHandle& nhPrivate);
        virtual ~TeamingPlanner();



}; // TeamingPlanner

#endif // TEAMING_PLANNER_H
